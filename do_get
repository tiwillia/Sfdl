#!/bin/bash
# get
# Written by Timothy Williams <tiwillia@redhat.com>


# The following is the only thing you need to set.
# This can be changed to anything you would like, as long as
# you have read/write privledges on the file
# Don't include / on the end
#-----------------------------------------------------------------------------
CONFIG_FILE_LOCATION=~/.config
CONFIG_FILE=get.cfg
#-----------------------------------------------------------------------------

# Declare colors for output - stolen from rsaw
if [[ $BASH_VERSINFO -ge 4 ]]; then
        declare -A c
        c[reset]='\033[0;0m';
	c[grey]='\033[00;30m';
        c[red]='\033[0;31m';
        c[green]='\E[0;32m';
        c[orange]='\033[0;33m';
fi

# Function to set up configuration file with user input
# This is pretty messy...
firstuse() {
	echo -e "Lets set up the configuration file"
	echo -e ""
	read -p "Access.RedHat.com Username (i.e. rhn-support-jdoe) " user
	echo -e ""
        local verify=2
	while [ $verify != 0 ]
	do
		read -s -p "Password: " pass1
		echo -e ""
		read -s -p "Verify Password: " pass2
		echo -e ""
		if [ ! $pass1 == $pass2 ]; then
			echo -e ${c[red]}"Passwords do not match, try again"${c[reset]}
			local verify=1
		else
			local verify=0
		fi
	done
	echo ""
	read -p "Directory to store case files in (i.e. /cases or /home/you/cases) " dldir
	echo ""
	if [ $(echo $dldir | grep "\/$">/dev/null; echo $?) == "0" ]; then
		local dldir=$(echo $dldir | sed s/.$//)
	fi
	if [ ! -d $CONFIG_FILE_LOCATION ]; then
		mkdir $CONFIG_FILE_LOCATION
	fi
	echo "# Automatically generated by get" > $CONFIG_FILE_LOCATION/$CONFIG_FILE
       	echo "#-------------------------------------------------------------" > $CONFIG_FILE_LOCATION/$CONFIG_FILE
       	echo "# USR should be your access.redhat.com username" > $CONFIG_FILE_LOCATION/$CONFIG_FILE
        echo "# PASS should be your password" > $CONFIG_FILE_LOCATION/$CONFIG_FILE
       	echo "# DIR should be your download location for the attachments" > $CONFIG_FILE_LOCATION/$CONFIG_FILE
	echo "" >> $CONFIG_FILE_LOCATION/$CONFIG_FILE
	echo "USR=$user" >> $CONFIG_FILE_LOCATION/$CONFIG_FILE
	echo "PASS=$pass1" >> $CONFIG_FILE_LOCATION/$CONFIG_FILE
	echo "DIR=$dldir" >> $CONFIG_FILE_LOCATION/$CONFIG_FILE
	echo -e ${c[green]}"Configuration file created in $CONFIG_FILE_LOCATION/$CONFIG_FILE"${c[reset]}
	echo ""
}

# Function that wll be looped to read the xml attachments file
# $IFS is the global field serperator
# by setting IFS to > and read delimiter to < 
# We can effectively seperate xml tags ($ENTITY) from xml content ($CONTENT)
# This function alone will read one line of xml
# This is why we run it in a while loop later on
read_xml() {
        local IFS=\>
        read -d \< ENTITY CONTENT
}

# Funtion to extract files
# This will also rename any sosreport directory by the following:
#  - "sosreport"
#  - hostname within sosreport
#  - date and time the sosreport was created
# This way, new sosreports will automatically not overwrite the old
# And we can easily identify which is which
extract() {
	if [ $# -ge 1 ]; then
	        echo -e ${c[grey]}"     Extracting $1..."${c[reset]}
		local dirname=`tar tf $1 | cut -d/ -f1 | head -n 1`
		if [[ $1 == sosreport* ]]; then
			tar xvf $1 >/dev/null
			chown -R $USER $dirname
        		chgrp -R $USER $dirname
        		chmod -R 755 $dirname
			if [ $OVERWRITE == "o" ]; then
                                rm -rf $(ls | grep ^sosreport | grep -v tar | grep -v tgz)
			fi
				local new_dirname=sosreport-$(head -n 1 $dirname/hostname)-$(head -n 1 $dirname/date | cut -d\  -f2,3 | sed s/\ //)-$(head -n 1 $dirname/date | cut -d\  -f4 | cut -d: -f1,2)
				mv -f $dirname $new_dirname
			        echo -e ${c[grey]}"     Extracted to $new_dirname"${c[reset]}
			        echo -e "	   - Extracted to $new_dirname" >> $CASE
		else
        		if [ $dirname == "." ]; then
				local newdir=$(echo $1 | cut -d. -f1)
				mkdir $newdir
				cd $newdir
				tar xvf ../$1 >/dev/null
				cd ..
				dirname=$newdir
			else
				tar xvf $1 >/dev/null
			fi
		        echo -e ${c[grey]}"     Extracted to $dirname"${c[reset]}
		        echo -e "     - Extracted to $dirname" >> $CASE
		fi
	else
		echo -e ${c[red]}"Internal get error - No paramater given"${c[reset]}
	fi
}

# Checks if configuration file exists. If not, creates it.
# Includes everything in the configuration file
#	-This actually brings a security vuln
if [ ! -e $CONFIG_FILE_LOCATION/$CONFIG_FILE ] | [ $1 == "--initial-setup" ] 2>/dev/null; then
	firstuse
fi
source $CONFIG_FILE_LOCATION/$CONFIG_FILE

# Check input and configuration from top of file
# If no case number was given, it will ask for it
if [ -z $USR ] || [ -z $PASS ] || [ -z $DIR ]; then
	echo -e "Variables not set, see configuration file or run get --initial-setup"
	exit 10
fi
if [ $# -ge 1 ] & [ $1 != "--initial-setup" ] 2>/dev/null; then
	CASE=$1
else
	read -p "Case Number: " CASE
fi

# Download the attachment xml file and rename it appropriately (it will be deleted later)
#cd $DIR/$CASE
wget --output-document=/tmp/LIST_$CASE --http-user=$USR --http-password=$PASS https://api.access.redhat.com/rs/cases/$CASE/attachments &> /dev/null
if [ $? != "0" ]; then
	echo -e  ${c[red]}"Was not able to get list of attachments"
	ping -w 2 api.access.redhat.com > /dev/null
	if [ $? != "0" ]; then
		echo -e "Could not reach https://api.access.redhat.com"
		echo -e "Check you network settings"${c[reset]}
		exit 2
	else
		echo -e "Check case number to be sure it exists and has attachments"
		echo -e "Check username and password and try again (see $CONFIG_FILE_LOCATION/$CONFIG_FILE)"
	        echo -e "If it still fails, be sure you have write privledges for $DIR/*"${c[reset]}
		exit 3
	fi
fi

echo -e "Attachments will be downloaded in $DIR/$CASE"

# Create case directory, or confirm overwrite if directory exists
if [ -e $DIR ]; then
        if [ -e $DIR/$CASE ]; then
                echo -n -e ${c[orange]}""
                read -n 1 -p "(o)verwrite files in $DIR/$CASE or only download the (n)ew? [o/n] " OVERWRITE_tmp
                OVERWRITE=$(echo $OVERWRITE_tmp | tr 'A-Z' 'a-z')
                echo -e ${c[reset]}""
                if [ $OVERWRITE != "o" ] && [ $OVERWRITE != "n" ]; then
                        echo -e "Invalid input, exiting"
                        exit 1
                fi
        else
                OVERWRITE=a
                mkdir $DIR/$CASE
        fi
else
        OVERWRITE=a
        mkdir -p $DIR/$CASE
        chown -R $USER $DIR
        chgrp -R $USER $DIR
        chmod -R 755 $DIR
fi
cd $DIR/$CASE

# Create or append to case log file
if [ ! -e $CASE ]; then
	echo -e "$CASE" >> $CASE
	echo -e "" >> $CASE
fi
echo -e "$(date +%a\ %b\ %Y%t%l:%M%p)" >> $CASE
echo -e "" >> $CASE
echo -e "List of files downloaded:" >> $CASE
echo -e "--------------------------" >> $CASE

# Parse through the xml file and download/rename attachments
# Will also call extract() for anything ending in .bz2 .tgz or tar.*z
while read_xml; do
	if [ $ENTITY == "uri" ] 2>/dev/null ; then
		DOWNLOAD=$CONTENT
	fi
	if [ $ENTITY == "fileName" ] 2> /dev/null ; then
		ls | grep $CONTENT &> /dev/null
		if [ $?  -eq "0" ] && [ $OVERWRITE == "n" ]; then
			echo -e ${c[grey]}"$CONTENT already exists, skipping download"${c[reset]}
		else
			wget --output-document=$CONTENT --http-user=$USR --http-password=$PASS $DOWNLOAD &> /dev/null
			echo -e ${c[green]}"Downloaded attachment $CONTENT"${c[reset]}
			du -h $CONTENT >> $CASE
			if [[ $CONTENT == *tar.*z ]] || [[ $CONTENT == *.bz2 ]] || [[ $CONTENT == *.tgz ]]; then
				extract $CONTENT
			fi
		fi
	fi
done < /tmp/LIST_$CASE

#Finish case file
echo -e "--------------------------" >> $CASE
echo -e "" >> $CASE

#Delete xml list file
rm -f /tmp/LIST_$CASE

#End, everything after this will be ignored
exit 0;
